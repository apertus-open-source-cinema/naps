import inspect
from textwrap import dedent, indent

from nmigen import *
import re

from util import yosys


class XilinxBlackbox(Elaboratable):
    """Wraps the a Xilinx ip as a convenient blackbox.
    """

    def __init__(self, **kwargs):
        self.module = self.module or self.__class__.__name__
        self.parameters = kwargs
        self.ports = yosys.get_module_ports(("+/xilinx/cells_xtra.v", "+/xilinx/cells_sim.v"), self.module)
        self.hierarchy = self._find_hierarchy(list(self.ports.keys()))
        self._generate_stub_file()
        self.signal_proxy = SignalProxy(self.hierarchy, self.ports, path=self.module)

        assert type(self) != XilinxBlackbox, "Do not instantiate `XilinxBlackbox` directly. Use its subclasses!"

    def elaborate(self, platform):
        m = Module()

        named_ports = {
            "{}_{}".format(self.ports[name]["direction"], name): signal
            for name, signal in self.signal_proxy.used_ports().items()
        }

        def legalize_parameter(parameter):
            if isinstance(parameter, bool):
                return "{}".format(parameter).upper()
            elif isinstance(parameter, str):
                return parameter.upper()
            else:
                return parameter

        legalized_parameters = {k: legalize_parameter(v) for k, v in self.parameters.items()}
        parameters = {"p_{}".format(k.upper()): v for k, v in legalized_parameters.items()}
        m.submodules.instance = Instance(self.module, **named_ports, **parameters)

        # print(named_ports)
        # print(parameters)

        return m

    def __getitem__(self, item):
        return self.signal_proxy.__getitem__(item)

    def __getattr__(self, item):
        return self.signal_proxy.__getattr__(item)

    def _find_hierarchy(self, names):
        if isinstance(names, list): names = {v: v for v in sorted(names)}
        if isinstance(names, str): return names

        hierarchy = names.copy()
        for hierarchy_name, full_name in names.items():
            added = False
            for merge_candidate_name in reversed(list(hierarchy.keys())):
                common_start = self._common_start(hierarchy_name, merge_candidate_name)

                prefix = None
                match = re.match("\\d", common_start)
                if match:
                    prefix = match[0]
                else:
                    match = re.match("[A-Z0-9]+", common_start)

                    if match:
                        if len(match[0]) >= 3:
                            prefix = match[0]
                        else:
                            children = self.potential_children(match[0], merge_candidate_name, hierarchy, hierarchy_name,
                                                            full_name)
                            if all(c[:1].isdigit() for c in children.keys()) and len(
                                    set(c[:1] for c in children.keys())) > 1:
                                prefix = match[0]

                if prefix:
                    children = self.potential_children(prefix, merge_candidate_name, hierarchy, hierarchy_name,
                                                       full_name)
                    if "" in children.keys():
                        continue

                    if prefix in hierarchy and isinstance(hierarchy[prefix], str):
                        continue

                    del hierarchy[merge_candidate_name]
                    try:
                        del hierarchy[hierarchy_name]
                    except KeyError:
                        pass

                    hierarchy[prefix] = children
                    added = True
                    break
            if not added:
                hierarchy[hierarchy_name] = full_name

        if "" in list(hierarchy.keys()):
            return list(hierarchy.values())[0]

        return {k: self._find_hierarchy(v) for k, v in hierarchy.items()}

    @staticmethod
    def potential_children(common_start, merge_candidate_name, hierarchy, hierarchy_name, full_name):
        strip = lambda s: s.replace(common_start, "")
        children = None
        if isinstance(hierarchy[merge_candidate_name], str):
            children = {strip(hierarchy_name): full_name, strip(merge_candidate_name): hierarchy[merge_candidate_name]}
        else:
            children = {strip(hierarchy_name): full_name,
                        **{strip(k): v for k, v in hierarchy[merge_candidate_name].items()}}
        return children

    def _generate_stub_file(self):
        stub_filename = "{}i".format(inspect.getfile(self.__class__))
        a = self.__class__
        autogen_begin_marker = "## begin autogenerated stub for class {class_name} by xilinx_blackbox.py DO NOT EDIT ##".format(
            class_name=self.__class__.__name__)
        autogen_end_marker = "## end autogenerated stub for class {class_name} by xilinx_blackbox.py ##".format(
            class_name=self.__class__.__name__)

        # remove (potentially existing) stubs
        try:
            with open(stub_filename, "r") as f:
                text = f.read()
                new_text = re.sub("{}.*{}".format(re.escape(autogen_begin_marker), re.escape(autogen_end_marker)), "",
                                  text, flags=re.M + re.S)
            with open(stub_filename, "w") as f:
                f.write(new_text.strip())
        except FileNotFoundError:
            pass

        # generate a new stub
        with open(stub_filename, "a") as f:
            def gen_class_body(hierarchy_part):
                to_class_name = lambda x: "_{}".format(x.lower().capitalize())

                def gen_class(class_name, children):
                    return "class {class_name}:\n{class_body}".format(
                        class_name=to_class_name(class_name),
                        class_body=indent(gen_class_body(children), "    ")
                    )

                def gen_single_child(children, hierarchy_name):
                    to_signal_name = lambda name: 'in_' if name.lower() == 'in' else name.lower()
                    if isinstance(children, str):
                        return "{}: Signal # {}".format(to_signal_name(hierarchy_name), children)
                    elif all(c.isdigit() for c in children.keys()):
                        classes = "\n".join(gen_class(k, v) for k, v in children.items() if isinstance(v, dict))
                        max_element = max(int(x) for x in children.keys())
                        tuple_inner = ", ".join(
                            "None" if not str(i) in children
                            else "_{}".format(i) if isinstance(children[str(i)], dict)
                            else "Signal"
                            for i in range(max_element+1)
                        )
                        return "{}\n{} : Tuple[{}]".format(classes, to_signal_name(hierarchy_name), tuple_inner)
                    else:
                        return "{class_str}\n{name} : {class_name}".format(
                            class_str=gen_class(hierarchy_name, children),
                            name=to_signal_name(hierarchy_name),
                            class_name=to_class_name(hierarchy_name)
                        )

                return "\n".join(
                    gen_single_child(v, k)
                    for k, v in hierarchy_part.items()
                )

            f.write(dedent("""
                {autogen_begin_marker}
                from nmigen import Signal
                from typing import Tuple
                class {class_name}:
                    def __init__(**kwargs):
                        pass
                {class_body}
                
                {autogen_end_marker}
            """).format(
                class_name=self.__class__.__name__,
                autogen_begin_marker=autogen_begin_marker,
                class_body=indent(gen_class_body(self.hierarchy), "    "),
                autogen_end_marker=autogen_end_marker))

    @staticmethod
    def _common_start(a, b):
        """Returns the characters two strings have in common in the beginning"""
        common_start = ""
        for i in range(min(len(a), len(b))):
            if a[i] == b[i]:
                common_start += a[i]
            else:
                break
        return common_start


class SignalProxy:
    def __init__(self, hierarchy, ports, path="/"):
        self.hierarchy = hierarchy
        self.ports = ports
        self.path = path

        self._used_ports = {}
        self.children = {}

    def used_ports(self):
        child_ports = {}
        for c in self.children.values():
            child_ports = {**child_ports, **c.used_ports()}
        return {**self._used_ports, **child_ports}

    def __getitem__(self, item):
        if isinstance(item, int):
            item = str(item)

        item = item.upper()
        if item not in self.ports:
            return getattr(self, item)
            # raise KeyError("{} not found in {}".format(item, self.path))

        # do the real signal finding
        if item not in self._used_ports:
            self._used_ports[item] = Signal(self.ports[item]["width"], name=item)
        return self._used_ports[item]

    def __getattr__(self, item):
        if item.startswith("__"):
            return

        if item == "in_":
            item = "in"

        item = item.upper()

        if item not in self.hierarchy:
            raise KeyError("{} not found in {}".format(item, self.path))
        requested = self.hierarchy[item]
        if isinstance(requested, dict):
            if item not in self.children:
                self.children[item] = SignalProxy(requested, self.ports, path="{}.{}".format(self.path, item))
            return self.children[item]

        # do the real signal finding
        if requested not in self._used_ports:
            self._used_ports[requested] = Signal(self.ports[requested]["width"], name=requested)
        return self._used_ports[requested]


class PortNotFoundException(Exception):
    pass
